// Generated by CoffeeScript 1.9.3

/*

Shows a series of directional arrows.
Useful for current and wind direction.
Scales number of arrows depending on space.

TODO: Implement more dynamic scalling.
 */
var calculate_layout, d3, moment, neighbours,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

d3 = require('d3');

moment = require('timespanner');

neighbours = require('../util/neighbours');

calculate_layout = function(dimensions) {
  var canvas, info, title;
  dimensions = {
    width: dimensions[0],
    height: 60
  };
  info = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 200
  };
  title = {
    top: 0,
    right: dimensions.width - info.left,
    bottom: 0,
    left: 0,
    height: dimensions.height,
    width: info.left
  };
  canvas = {
    top: info.top,
    right: info.right,
    bottom: info.bottom,
    left: info.left,
    width: dimensions.width - info.left - info.right,
    height: dimensions.height - info.top - info.bottom
  };
  return {
    dimensions: dimensions,
    info: info,
    title: title,
    canvas: canvas
  };
};

module.exports = function(spec, components) {
  var axis, calculate_direction, data, drawArrow, focus, inner, result, scale, sections, svg, updatepoi;
  drawArrow = function(dir, section) {
    var arrow;
    section.selectAll('*').remove();
    arrow = section.append('g').attr('transform', 'rotate(' + (dir + 180) + ', 0, 10)');
    arrow.append('path').attr('class', 'arrowhead').attr('d', d3.svg.symbol().type('triangle-up').size(20));
    arrow.append('line').attr('class', 'arrowline').attr('x1', 0).attr('x2', 0).attr('y1', 3).attr('y2', 20);
    return section.append('text').attr('class', 'label').text("" + (dir.toFixed(0)) + spec.units).attr('text-anchor', 'middle').attr('transform', "translate(0,35)");
  };
  calculate_direction = function(degree) {
    var direction, text, textDirection;
    direction = Math.floor((degree / 22.5) + 0.5);
    text = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
    return textDirection = text[modulo(direction, 16)];
  };
  svg = null;
  inner = null;
  scale = null;
  axis = null;
  focus = null;
  updatepoi = null;
  data = null;
  sections = null;
  return result = {
    render: function(dom, state, params) {
      var arrow, bisector, drag, filteredData, layout, poi, poifsm, section;
      layout = calculate_layout(params.dimensions);
      svg = d3.select(dom).append('svg').attr('class', 'item direction');
      data = state.data;
      svg.append('g').attr('class', 'title').attr('transform', "translate(" + layout.title.left + "," + layout.title.top + ")").append('text').attr('class', 'infotext').text(spec.text).attr('dy', 18);
      inner = svg.append('g').attr('class', 'inner').attr('transform', "translate(" + layout.canvas.left + "," + layout.canvas.top + ")");
      inner.append('line').attr('class', 'divider').attr('x1', 0).attr('x2', 0).attr('y1', 0).attr('y2', layout.dimensions.height);
      filteredData = data.filter(function(d) {
        return +d.time >= +params.domain[0] && +d.time <= +params.domain[1];
      });
      scale = d3.time.scale().domain(params.domain).range([0, layout.canvas.width]);
      bisector = d3.bisector(function(d) {
        return d.time;
      }).left;
      data = scale.ticks(d3.time.hour, 3).map(function(d) {
        var index;
        index = bisector(filteredData, d);
        return filteredData[index];
      }).filter(function(d) {
        return d != null;
      });
      sections = svg.select('.inner').selectAll('.section').data(data);
      section = sections.enter().append('g').attr('class', function(d) {
        var hour;
        hour = d.time.local().get('hour');
        if (hour % 12 === 0) {
          return 'section priority1';
        } else if (hour % 6 === 0) {
          return 'section priority2';
        } else if (hour % 3 === 0) {
          return 'section priority3';
        }
      });
      arrow = section.append('g').attr('transform', function(d) {
        return "rotate(" + (d[spec.field] + 180) + ", 0, 9)";
      });
      arrow.append('path').attr('class', 'arrowhead').attr('d', d3.svg.symbol().type('triangle-up').size(20));
      arrow.append('line').attr('class', 'arrowline').attr('x1', 0).attr('x2', 0).attr('y1', 3).attr('y2', 20);
      section.append('text').attr('class', 'label').text(function(d) {
        return calculate_direction(d[spec.field]);
      }).attr('text-anchor', 'middle').attr('transform', "translate(0,40)");
      focus = inner.append('g').attr('class', 'focus');
      focus.append('line').attr('class', 'poi').attr('display', 'none').attr('y1', 0).attr('y2', layout.dimensions.height);
      focus.append('circle').attr('class', 'arrow-background').attr('r', 25).attr('display', 'none');
      focus.append('g').attr('class', 'foc-section').attr('display', 'none');
      poi = null;
      params.hub.on('poi', function(p) {
        poi = p;
        return updatepoi();
      });
      poifsm = {
        hide: function() {
          if (poi === null) {
            return;
          }
          return params.hub.emit('poi', null);
        },
        show: function(x) {
          var d, range;
          range = scale.range();
          if (range[0] > x || range[1] < x) {
            return poifsm.hide();
          }
          d = scale.invert(x);
          if (poi === d) {
            return;
          }
          return params.hub.emit('poi', moment.utc(d));
        },
        update: function() {
          var dist, x;
          x = d3.mouse(inner.node())[0];
          if (poifsm.startx != null) {
            dist = Math.abs(poifsm.startx - x);
            if (dist < 10) {
              return;
            }
          }
          poifsm.startx = null;
          return poifsm.show(x);
        },
        mousedown: function() {
          var x;
          x = d3.mouse(inner.node())[0];
          if (poifsm.currentx == null) {
            return poifsm.show(x);
          }
          return poifsm.startx = x;
        },
        mouseup: function() {
          var dist, x;
          if (poifsm.startx == null) {
            return;
          }
          if (!poifsm.currentx) {
            poifsm.startx = null;
            return poifsm.hide();
          }
          dist = Math.abs(poifsm.startx - poifsm.currentx);
          if (dist < 10) {
            poifsm.startx = null;
            return poifsm.hide();
          }
          x = d3.mouse(inner.node())[0];
          return poifsm.show(x);
        }
      };
      drag = d3.behavior.drag().on('drag', poifsm.update);
      focus.append('rect').attr('class', 'foreground').attr('height', layout.canvas.height).attr('width', layout.canvas.width).style('fill', 'none').on('mousedown', poifsm.mousedown).on('mouseup', poifsm.mouseup).call(drag);
      updatepoi = function() {
        var Neighbours, d, d0, d1, halfway, poiNeighbours, xVal;
        if (poi == null) {
          focus.select('line.poi').attr('display', 'none');
          focus.select('.foc-section').attr('display', 'none');
          focus.select('.arrow-background').attr('display', 'none');
          return;
        }
        poifsm.currentx = scale(poi);
        focus.select('line.poi').attr('display', null).attr('x1', scale(poi)).attr('x2', scale(poi));
        Neighbours = neighbours(filteredData, function(d) {
          return d.time;
        });
        poiNeighbours = Neighbours(poi);
        d;
        if (poiNeighbours.length === 1) {
          d = poiNeighbours[0];
        } else if (+poiNeighbours[0].time < +params.domain[0]) {
          d = poiNeighbours[1];
        } else if (+poiNeighbours[1].time > +params.domain[1]) {
          d = poiNeighbours[0];
        } else {
          d0 = poiNeighbours[0];
          d1 = poiNeighbours[1];
          halfway = d0.time + (d1.time - d0.time) / 2;
          d = poi.isBefore(halfway) ? d0 : d1;
        }
        drawArrow(d[spec.field], focus.select('.foc-section'));
        if ((layout.canvas.width - scale(poi)) < 27) {
          xVal = layout.canvas.width - 27;
        } else if ((layout.canvas.left + scale(poi)) < 227) {
          xVal = 27;
        } else {
          xVal = scale(d.time);
        }
        focus.select('.arrow-background').attr('display', null).attr('transform', "translate(" + xVal + ", " + (layout.canvas.height / 2) + ")");
        return focus.select('.foc-section').attr('display', null).attr('transform', "translate(" + xVal + ", " + ((layout.canvas.height / 2) - 17) + ")");
      };
      return result.resize(params.dimensions);
    },
    resize: function(dimensions) {
      var layout, minLabelWidth, p1, p1widths, p2, p2widths, p3, p3widths;
      layout = calculate_layout(dimensions);
      svg.attr('width', layout.dimensions.width).attr('height', layout.dimensions.height);
      scale.range([0, layout.canvas.width]);
      sections.attr('transform', function(d) {
        return "translate(" + (scale(d.time)) + ", 10)";
      });
      p1 = inner.selectAll('.priority1');
      p2 = inner.selectAll('.priority2');
      p3 = inner.selectAll('.priority3');
      minLabelWidth = 31;
      p1widths = p1[0].length * minLabelWidth;
      p2widths = p2[0].length * minLabelWidth;
      p3widths = p3[0].length * minLabelWidth;
      switch (false) {
        case !(p1widths + p2widths + p3widths <= layout.canvas.width):
          p2.attr('display', 'inline');
          p3.attr('display', 'inline');
          break;
        case !(p1widths + p2widths <= layout.canvas.width):
          p2.attr('display', 'inline');
          p3.attr('display', 'none');
          break;
        case !(p1widths <= layout.canvas.width):
          p3.attr('display', 'none');
          p2.attr('display', 'none');
      }
      return updatepoi();
    }
  };
};
